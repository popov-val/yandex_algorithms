# https://contest.yandex.ru/contest/25597/run-report/136467045/
"""
-- ПРИНЦИП РАБОТЫ --
1) Читаем данные
2) Собираем массив dp (вместо него используем текущий и предыдущие шаги)
3) Проходимся по каждой букве каждой строки
    Собираем текущий массив
    Если буквы равны берем "диагональный" элемент
    Если нет, берем минимум от соседей и увеличиваем на 1 символ
    Меняем предыдший массив на текущий для следующего шага

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Рассмотрим все случаи
1) равенство - берется диаганальный слева сверху
2) "удаление" - берется верхнее значение
3) "вставка" - берется элемент слева
4) "замена" - берется диаганальный, но добавляется единица

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
N - длина первой строки
M - длина второй строки
Итого: O(N*M)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Итого: O(N*2) - два массива длиной одной из строк
"""


def main():
    s = input()
    t = input()
    l_s = len(s)
    l_t = len(t)
    prev = list(range(l_s + 1))
    curr = [l_s]
    for i in range(1, l_t + 1):
        curr = [i]
        for j in range(1, l_s + 1):
            if t[i - 1] == s[j - 1]:
                curr.append(prev[j - 1])
            else:
                curr.append(min(curr[j - 1],
                                prev[j], prev[j - 1]) + 1)
        prev = curr

    return curr[-1]


if __name__ == '__main__':
    print(main())
